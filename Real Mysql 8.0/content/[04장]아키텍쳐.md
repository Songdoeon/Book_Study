## 🌈 Chapter 4 : 아키텍쳐

Mysql 서버는 사람의 머리 역할을 담당하는 MySQL 엔진과 손발 연할을 담당하는 스토리지 엔진으로 구분할 수 있다.

스토리지 엔진은 핸들러 API를 만족하면 누구든 스토리지 엔진을 구현해서 MySQL 서버에 추가해서 사용할 수 있다.

우리는 MySQL 엔진과 MySQL 서버에서 기본으로 제공되는 InnoDB 스토리지 엔진 스리고 MyISAM 스토리지 엔진을 구분해서 살펴보겠다.

## 📚 LESSEN 1 : MySQL 엔진 아키텍쳐

먼저 MySQL의 쿼리를 작성하고 튜닐할 때 필요한 기본적인 MySQL 엔진의 구조를 훑어보겠다.

MySQL 서버는 다른 DBMS에 비해 구조가 상당히 독특하다. 사용자 입장에서는 차이가 적을 수 있지만, 이러한 독특한 구조 덕에 다른 DBMS는 가질 수 없는 엄청난 혜택을 누리기도 하지만 문제가 되기도 한다.
 
### 🎈 MySQL의 전체구조

 ![image](https://github.com/Songdoeon/Book_Study/assets/96420547/88e55be0-38ba-4930-9719-04fbf4016648)

MySQL 서버는 크게 MySQL 엔진과 스토리지 엔진으로 구분할 수 있다.

우리는 MySQL의 쿼리파서나 옵티마이저 등과 같은 기능을 스토리지 엔진과 구분하고자 위 처럼 엔진을 구분했다. 그리고 이 둘을 모두 합쳐 그냥 MySQL 또는 MySQL 서버라고 표현하겠다.

- MySQL 엔진
  - 클라이언트로부터의 접속 및 쿼리 요청을 처리하는 커넥션 핸들러와 SQL 파서 및 전처리기, 쿼리의 최적화된 실행을 위한 옵티마이저가 중심을 이룬다.
  - 요청된 SQL 문장을 분석하거나 최적화 하는 등 DBMS의 두뇌에 해당하는 처리를 수행한다.
  - MySQL 서버에 단 하나이다.
  - 표준 SQL(ANSI SQL)문법을 지원하므로 표준 문법에 따라 작성된 쿼리는 타 DBMS와 호환된다.
- 스토리지 엔진
  - 실제 데이터를 디스크 스토리지에 저장하거나 디스크 스토리지로부터 데이터를 읽어오는 부분을 전담한다.
  - MySQL 서버에 여러 개를 동시에 사용할 수 있다.
  - 테이블이 사용할 스토리지 엔진을 지정하면 이후 해당 테이블의 모든 작업은 정의된 스토리지 엔진이 처리한다.
  - 각 스토리지 엔진은 성능 향상을 위해 키 캐시(ISAM)나 버퍼 풀(Inno DB)같은 기능을 내장하고 있다.
- 핸들러 API
  - MySQL의 쿼리 실행기가 쓰기, 읽기를 위해 스토리지 엔진에 요청할때 사용되는 API이다.
  - 스토리지 엔진 또한 이 핸들러 API를 이용하여 MySQL 엔진과 데이터를 주고 받는다.

### 🎈 MySQL의 스레딩 구조

<img width="745" alt="image" src="https://github.com/Songdoeon/Book_Study/assets/96420547/86f2fe97-db36-455f-a3ad-d767a9cc07cc">


MySQL 서버는 프로세스 기반이 아니라 스레드 기반으로 작동하며, 크게 포그라운드(foreground)스레드와 백그라운드(background)스레드로 구분한다.

#### 📕 포그라운드 스레드(클라이언트 스레드)
- 최소한 MySQL 서버에 접속된 클라이언틔 수 만큼 존대
- 주로 각 클라이언트 사용자가 요청하는 쿼리 문장을 처리한다.
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커넥션을 담당하던 스레드는 다시 스레드 캐시로 돌아간다.
  - 이때 이미 스레드 캐시에 일정 개수 이상의 대기 중인 스레드가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 캐시에 존재하게 한다.
  - `thread_cache_size` : 스레드 캐시에 유지할 수 있는 최대 스레드 개수
- 데이터를 MySQL의 데이터 버퍼나 캐시로 부터 가져오며, 없을 경우 직접 디스크의 데이터나 인덱스 파일로 부터 데이터를 읽어 작업한다.
- MyISAM 테이블은 디스크 쓰기 작업까지 포그라운드 스레드가 처리함(지연 쓰기가 있지만 일반적인 방식은 아님)
- InnoDB 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 나머지 버퍼로 부터 디스크까지 기록하는 작업은 백스레드가 처리한다.

#### 📕 백그라운드 스레드
- ISAM의 경우 별 해당사항이 없지만 InnoDB는 다음과 같은 여러작업이 백그라운드로 처리된다.
  - 인서트 버퍼(Insert Buffer)를 병합하는 스레드
  - 로그를 디스크로 기록하는 스레드
  - InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드
  - 데이터를 버퍼로 읽어 오는 스레드
  - 잠금이나 데드락을 모니터링하는 스레드
- 로그 스레드와 버퍼의 데이터를 디스크로 내려쓰는 작업을 처리하는 쓰기 스레드가 좀 중요함
- InnoDB도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되므로 읽기 스레드는 많이 설정할 필요 없음
- 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리함
  - 일반적인 내장 디스크를 사용할 때는 2~4 정도
  - DAS나 SAN과 같은 스토리지를 사용할 때는 디스크를 최적으로 사용할 수 있을 만큼 충분히 설정하는게 좋다.

- 사용자의 요청을 처리하는 도중 쓰기 작업은 지연(버퍼링)되어 처리될 수 있지만 데이터의 읽기 작업은 절대 지연될 수 없다.
  - 사용자가 SELECT 쿼리를 실행했는데, "요청된 SELECCT는 10분 뒤에 결과를 돌려주겠다" 라고하는 DBMS는 없다.
- 사용 DBMS는 대부분 쓰기 작업을 버퍼링해서 일괄 처리하는 기능이 있으며 InnoDB 또한 그러하다.
  - INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 저장 될 때까지 기다리지 않아도 됨
- 하지만 MyISAM은 그렇지 않고 사용자 스레드가 쓰기 작업까지 함께 처리하도록 되어있음
  - 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다.
 
### 🎈 메모리 할당 및 사용 구조
MySQL에서 사용되는 메모리 공간은 글로벌 메모리 영역과 로컬 메모리 영역으로 구분할 수 있다.

글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.

운영체제별 할당 방식은 복잡하므로 단순하게 MySQL의 시스템 변수설정에 따라 메모리를 할당받는다고 생각해도 된다.

#### 📕 글로벌 메모리 영역
일반적으로 클라이언트 스레드의 수와 무관하게 하나의 메모리 공간만 할당된다.(필요에 따라 2개 이상도 가능)

생성된 글로벌 영역이 N개라도 모든 스레드에 의해 공유된다. 대표적인 글로벌 메모리 영역은 다음과 같다.

- 테이블 캐시
- InnoDB 버퍼 풀
- InnoDB 어댑티브 해시 인덱스
- InnoDB 리두 로그 버퍼

#### 📕 로컬 메모리 영역(세션, 커넥션 메모리 영역)
MySQL 서버상 존재하는 클라이언트 스레드가 쿼리를 처리하는 데 사용하는 메모리 영역이다.

클라이언트가 접속하면 서버에서 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당하게 되는데 클라이언트 스레드가 사용하는 메모리 공간이라고 해서 클라이언트 메모리 영역이라고도 한다.

- 로컬 메모리는 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다.
- 크게 신경 쓰지 않고 설정하면 가능성은 낮지만 메모리 부족이 발생한다.
- 각 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우에는 MySQL이 메모리 공간을 할당조차도 하지 않을 수도 있다.
- 커넥션이 열려 있는 동안 계속 할당된 상태로 남아 있는 공간은 다음과 같다.
  - 커넥션 버퍼
  - 결과 버퍼
- 쿼리를 실행하는 순간에만 할당했다 다시 해제하는 공간은 다음과 같다.
  - 정렬 버퍼(Sort buffer)
  - 조인 버퍼
- 대표적인 로컬 메모리 영역은 다음과 같다.
  - 정렬 버퍼
  - 조인 버퍼
  - 바이너리 로그 캐시
  - 네트워크 버퍼

### 🎈 플러그인 스토리지 엔진 모델
MySQL의 독특한 구조 중 대표적인 것이 바로 플러그인 모델이다.

전문 검색 엔진을 위한 검색어 파서, 사용자 인증을 위한 Native Authentication과 Caching SHA-2 Authentication 등도 모두 플러그인으로 구현되어 제공된다.
