## 🌈 Chapter 7: 분산 시스템을 위한 유일ID 생성기 설계

<details><summary>정리</summary>
  
  ```
  분산 시스템에서 적용할 수 있는 유일성 보장ID 만드는 기법
  - 다중 마스터 복제(multi-master replication)
  - UUID(Universally Unique Identifier)
  - 티켓 서버(ticker server)
  - 트위터 스노플레이크(twitter snowflake) 접근법
  ```
    
</details>

보통 생각하는 Auto_increment 속성은 분산 환경에서 적용할 수 없다.

DB 서버 한 대로는 그 요구를 감당할 수 없을뿐더러, 여러 DB 서버를 쓰는 경우에는 지연시간을 낮추기가 무척 힘들 것이기 때문이다.

### 📚 1단계 : 문제 이해 및 설계 범위 확정
---
우리가 이번에 따를 요구사항이다
- ID는 유일해야 한다.
- ID는 숫자로만 구성되어야 한다.
- ID는 64비트로 표현될 수 있는 값이어야 한다.
- ID는 발급날짜에 따라 정렬 가능해야 한다.
- 시스템 규모를 측정
  - Ex) 초당 10000개의 ID를 생성할 수 있어야 한다.

### 📚 2단계 : 개략적 설계안 제시 및 동의 구하기
---
분산 시스템에서 유일성이 보장되는 ID를만드는 방법은 여러 가지다.
- 다중 마스터 복제(multi-master replication)
- UUID(Universally Unique Identifier)
- 티켓 서버(ticker server)
- 트위터 스노플레이크(twitter snowflake) 접근법


#### 🎈 다중 마스터 복제

이 접근법은 auto_increment 기능을 활용한다.
- k개의 서버가 있다면 다음 ID를 k만큼 증가시킨다.
- DB 수가 늘어나면 초당 생산 가능 ID수도 늘릴 수 있다.

  → 규모 확장성 문제를 어느 정도 해결

단점
- 여러 데이터센터에 걸쳐 규모를 늘리기 어렵다.
- ID의 유일성은 보장되겠지만 그 값이 시간 흐름에 맞추어 커지로고 보장할 수는 없다.
- 서버를 추가하거나 삭제할 때도 잘 동작하도록 만들기 어렵다.

#### 🎈 UUID

UUID는 컴퓨터 시스템에 저장되는 정보를 유일하게 식별하기 위한 128비트짜리 수다.

UUID 형식 : 09c93e62-50b4-478d-bf8a-c07e1040bfb2

장점
- 충돌 가능성이 지극히 낮다.
  - 중복 UUID가 나올 확률을 50%까지 올릴려면 초당 10억개의 UUID를 100년동안 만들어야한다.
- 서버간 조율 없이 독립적으로 생성 가능하다
  - 서버간 동기화 이슈 X
- 각 서버가 자기가 쓸 ID를 알아서 만드는 구조이므로 규모 확장도 쉽다.

단점
- ID가 128비트로 길다
- ID를 시간순으로 정렬할 수 없다.
- ID에 숫자가 아닌 값이 포함될 수 있다.

#### 🎈 티켓 서버
이 아이디어의 핵심은 auto_increment 기능을 갖춘 데이터베이스 서버, 즉 티켓 서버를 중앙 집중형으로 하나만 사용하는 것이다.

장점
- 유일성이 보장되는 오직 숫자로만 구성된 ID를 쉽게 만들 수 있다.
- 구현하기 쉽고 중소 규모 애플리케이션에 적합하다.

단점
- 티켓 서버가 SPOF가 된다.
- SPOF를 피하기 위해서는 여러 디켓 서버를 준비해야한다.
  
   → 그렇게 되면 데이터 동기화 문제가 발생한다.

#### 🎈 트위터 스노플레이크 접근법
ID를 바로 생성하는 대신 각개 격파 전략(divie and conquer)을 적용해보자

생성해야하는 ID의 구조를 여러 절로 분할하는 것이다.
![image](https://github.com/Songdoeon/Book_Study/assets/96420547/77afed98-8ed0-4124-bd8d-ec3c4fe6b7c0)

- 사인(sign) 비트
  
  - 음수와 양수를 구별한다.
- 타임스탬프(timestamp) 비트
  - 기원 시각 이후로 몇 밀리초가 경과했는지를 나타내는 값이다.
  - `1288834974657` == `Nov 04, 2010, 01:42:54 UTC`
- 데이터 센터 비트
  - 비트 n의 수만큼 2^n의 데이터베이스를 지원할 수 있다.
  - 5비트 라면 2^5 = 32개의 센터 지원 가능
- 서버 비트
  - DB당 사용할 수 있는 서버의 수
  - 5비트 라면 DB센터 하나당 2^5 = 32개의 서버를 사용 가능
- 일련 번호
  - 각 서버에서 ID를 생성할 때마다 1 증가시킨다.
  - 이 값은 1밀리초가 경과할 때마다 0으로 초기화된다.

### 📚 3단계 : 상세 설계
---
트위터 스노플레이크 접근법을 사용하여 상세한 설계를 해보자.

- 데이터센터 ID와 서버 ID는 시스템이 시작할 때 결정되며, 일반적으로 시스템 운영중에는 바뀌지 않는다.
  - 잘못 변경하게 되면 ID 충돌 발생
- 타임스탬프나 일련번호는 ID 생성기가 돌고 있는 중에 만들어지는 값이다.

#### 🎈 타임스탬프

타임 스탬프는 앞서 살펴본 ID 구조에서 가장 중요한 41비트를 차지하고 있다.
- 시간의 흐름에 따라 점점 큰 값을 갖는다.
- 41비트로 표현할 수 있는 타임스탬프의 최댓값은 2^41 - 1 = 2199023255551밀리초 이다
  - 이 값은 대략 69년에 해당한다.
  - 69년 뒤에는 기원 시각을 바꾸거나 ID체계를 다른 것으로 이전(migration) 해야한다.
- Ex) UTC시각 추출법
<img src = "https://github.com/Songdoeon/Book_Study/assets/96420547/8e7108d1-e148-4121-82e9-c7f245775104" width = 750 height = 400>

#### 🎈 일련번호

일련번호는 12비트 이므로 4096개의 값을 가질 수 있다.

어떤 서버가 같은 밀리초 동안 하나 이상의 ID를 만들어 낸 경우에만 0보다 큰 값을 갖게된다.

### 📚 4단계 : 마무리

- 시계 동기화(clock synchronization)
  
  - ID 생성 서버가 같은 시계를 사용하지 않을 수 있음
  - 하나의 서버가 여러 코어에서 실행될 경우 문제 발생
  - NTP(Network Time Protocol)은 이 문제를 해결하는 보편적 수단
- 각 절(section)의 길이 최적화
  - 동시성이 낮고 수명이 긴 애플리케이션이라면?
    - 일련번호의 절 길이를 줄이고 타임스탬프의 절 길이를 늘리는 것이 효과적일 수 있음
- 고가용성
  - ID 생성니느 필수 불가결 컴포넌트 이므로 아주 높은 가용성을 제공해야 할 것이다.


