## 🌈 Chapter 1: 사용자 수에 따른 규모 확장성

<details><summary>정리</summary>

  
  - 웹 계층은 무상태 계층으로
  - 모든 계층에 다중화 도입
  - 가능한 많은 데이터를 캐시할 것
  - 여러 데이터센터를 지원할 것
  - 정적 콘텐츠는 CDN을 통해 서비스 할 것
  - 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
  - 각 계층은 독립적 서비스로 분할할 것
  - 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것
    
</details>

- 수백만 사용자를 지원하는 시스템을 설계하는 것은 도전적이며, 지속적인 계량과 끝없는 개선이 요구함.
- 한 명의 사용자를 지원하는 시스템에서부터 최종적으로 몇백만 사용자를 지원하는 시스템 설계를 시도한다.
  

### 📚 단일 서버
---
- 웹 앱, 데이터베이스, 캐시 등이 전부 서버 한대에서 실행되는 서버

#### 🎈 사용자 요청 처리 흐름
  - 사용자가 도메인 이름을 이용하여 웹사이트 접속
    
    → 접속을 위해선 도메인 이름을 도메인 이름 서비스(DNS)에 질의해 IP로 변환
    
    → DNS는 보통 제3 사업자가 제공하는 유료 서비스 사용함
    
  - DNS 조회 결과를 IP 주소로 반환
  - 해당 IP 주소로 HTTP 요청 전달
  - 요청을 받은 웹서버는 HTML 페이지나 JSON 형태의 응답을 반환한다.
    
#### 🎈 사용자 요청 오는 단말 종류
  - 웹 어플리케이션
    
    → 비즈니스 로직, 데이터 저장등을 위한 서버 구현용 언어(자바, 파이썬)를 사용
    
    → 프레젠테이션용으로는 클라이언트 구현용 언어(HTML, JavaScript)를 사용
    
  - 모바일 앱
    
    → 모바일 앱과 웹 서버간 통신을 위해 HTTP 프로토콜을 이용

    → HTTP 프로토콜을 통해 반환될 응답 데이터의 포맷으로는 보통 JSON이 쓰인다.
    

### 📚 데이터베이스
---
- 사용자가 늘면 서버 하나로는 충분하지 않아서 여러 서버를 두어야한다.
- 하나는 웹 / 모바일 트래픽 처리용, 다른 하나는 데이터베이스용이다.
- 서버를 분리하여 각각 독립적으로 확장 할 수 있도록 한다.

#### 🎈 어떤 데이터베이스를 사용할것인가?
  - 관계형 데이터베이스
    - MySQL, Oracle, PostgreSQL
    - 자료를 테이블과 열, 칼럼으로 표현한다.
    - SQL을 사용하면 여러 테이블에 있는 데이터를 그 관계에 따라 조인하여 합칠 수 있다.
  - 비 관계형 데이터베이스
    - CouchDB, Neo4j, Cassandra, HBase, Amazon DynamoDB
    - 키-값 저장소, 그래프 저장소, 칼럼 저장소, 문서 저장소 4분류로 나눈다.
    - 일반적으로 조인연산 지원하지 않음
  - 비 관계형 데이터베이스가 바람직한 경우
    - 아주 낮은 응답 지연시간이 요구됨
    - 다루는 데이터가 비정형데이터
    - 데이터를 직렬화 하거나 역직렬화 할 수 있기만 하면됨
    - 아주 많은 양의 데이터를 저장해야함
   
   
### 📚 Scale Up vs Scale Out
---
- Scale Up (수직적 규모 확장)
  - 서버에 고사양 자원(CPU, RAM)을 추가하는 행위
  - 한대의 서버에 CPU나 메모리를 무한대로 증설할 방법은 없다.
  - 장애에 대한 자동복구 방안이나 다중화 방안을 제시하지 않는다.
 
- Scale Out (수평적 규모 확장)
  - 더 많은 서버를 추가하여 성능을 개선하는 행위
  - 대규모 어플리케이션 지원에 적절하다.

#### 🎈 로드 밸런서
  - 부하 분산 집합에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할
  - 많은 사용자로 인한 한계상황에서 응답속도 지연이나 서버 접속불가 등을 해결할 수 있음
  - 웹 서버를 추가하여 장애 복구 및 웹 계층 가용성을 향상 시켜줌
  - 데이터 계층 장애를 해결하는 구성은 아님
    
#### 🎈 데이터베이스 다중화
  - 서버 사이에 주(master) - 부(slave) 관계를 설정하여 데이터 원본은 주 서버에 사본은 부 서버에 저장하는 방식을 사용
    
    - 쓰기 연산(Insert, Delete, Update)은 주 데이터베이스에서 지원
    - 읽기 연산은 부 데이터베이스에서 지원
  - 대부분의 어플리케이션은 읽기 연산 비중이 크다.
    - 부 데이터베이스의 수가 주 데이터베이스 수 보다 많다.
  
#### 🎈 다중화로 얻을 수 있는 이득
  - 더 나은 성능
    
    - 쓰기, 읽기 연산 분산으로 병렬 처리될 수 있는 질의 수가 늘어남
  - 안정성
    - 데이터를 여러 지역에 다중화 시켜 자연 재해 등의 이유로 데이터베이스 서버가 일부 파괴되어도 데이터를 보존할 수 있음
  - 가용성
    - 하나의 서버에 장애가 발생하여도 다른 서버의 데이터를 사용하여 서비스 지속 가능
      
#### ❓ 데이터베이스 서버가 하나 다운되었다면?
  - 부 서버가 다운되었을 경우
    
    - 부 서버가 하나라면 읽기 연산은 한시적으로 주 데이터베이스로 전달
    - 새로운 부 데이터베이스 서버가 장애를 대체
  - 주 서버가 다운되었을 경우
    - 부 서버가 하나라면 해당 부 서버가 새로운 주 서버가 됨
      → 모든 데이터베이스 연산을 일시적으로 주 서버에서 수행
    - 해당 주 서버에 보관된 데이터가 최신 상태가 아닐 수 있음
      → 없는 데이터는 복수 스크립트를 돌려 추가해야함
      → 다중 마스터나 원형 다중화 방식을 도입하면 대처 가능 (복잡함)


### 📚 캐시
---
  - 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 이후 요청이 보다 빨리 처리될 수 있도록 하는 저장소
  - 어플리케이션의 성능은 데이터베이스를 얼마나 자주 호출하느냐에 크게 좌우되는데 그런 문제를 해결할 수 있음
  - 정적 콘텐츠를 콘텐츠 전송 네트워크(CDN)으로 옮기면 응답 시간을 개선할 수 있음

#### 🎈 캐시 계층
  - 데이터가 잠시 보관되는 곳으로 DB보다 훨씬 빠름
  - 성능 개선 및 DB 부하를 줄일 수 있음
  - 캐시 계층 규모를 독립적으로 확장시키는것도 가능
  - 일반적으로 API를 제공
  - 읽기 주도형 캐시전략
    - 캐시에 응답이 저장되어 있는지 확인
    - 없는 경우 DB질의를 통해 데이터를 찾아 캐시에 저장한 뒤 클라이언트에 반환
  - 데이터 종류, 크기, 액세스 패턴에 맞는 다양한 캐시 전략을 선택하여 사용

#### 🎈 캐시 사용시 유의점
  - 캐시는 어떤 상황에 바람직한가?
    
    → 데이터 갱신은 자주 일어나지 않지만, 참조가 빈번하게 일어나는 상황
    
- 어떤 데이터를 캐시에 두어야 하는가?
    
    → 영속적으로 보관할 데이터는 적합하지 않음 (중요한 데이터는 지속적 저장소에 두기)
    
    - 캐시 = 데이터를 취발성 메모리에 둠 = 캐시 서버가 재시작되면 캐시 내의 모든 데이터는 사라짐
- 캐시에 보관된 데이터는 어떻게 만료 되는가?
    
    → 관련한 정책을 마련해, 만료된 데이터는 캐시에서 삭제되어야 함
    
    - 만료 기한 너무 짧음 : 데이터베이스 너무 자주 읽게 됨
    - 만료 기한 너무 김 : 데이터가 원본과 차이가 날 가능성 높아짐
- 일관성은 어떻게 유지되는가?
    
    → 저장소의 원본을 갱신하는 연산과 캐시를 갱신하는 연산이 단일 트랜잭션으로 이루어져야함
    
    > 일관성 : 데이터 저장소의 원본과 캐시 내의 사본이 같은지 여부
    > 
- 장애에는 어떻게 대처할 것인가?
    
    → SPOF를 피하기 위해 여러 지역에 걸쳐 캐시 서버 분산해 장애 발생 피해야함
    
    - 캐시 서버를 한 대만 두는 경우 해당 서버는 단일 장애 지점(SPOF)가 됨
        
        > SPOF  : 어떤 특정 지점에서의 장애가 전체 시스템의 동작을 중단시켜버릴 수 있는 경우
        > 
- 캐시 메모리는 얼마나 크게 잡을 것이가?
    
    → 캐시 메모리는 과할당 해야함
    
    - 캐시 메모리가 작으면 액세스 패턴에 따라 데이터가 자주 캐시에서 밀려나버림
- 데이터 방출 정책은 무엇인가?
    
    > 데이터 방출 정책 : 캐시가 다 차면 추가로 캐시 데이터를 넣기 위해 기존 데이터 내보냄
    > 
    - LRU(Least Recently Used) : 마지막으로 사용된 시점이 가장 오래된 데이터 내보내는 정책
    - LFU(Least Frequently Used) : 사용된 빈도가 가장 낮은 데이터를 내보내는 정책
    - FIFO(First in First Out) : 가장 먼저 캐시에 들어온 데이터를 가장 먼저 내보내는 정책
    
    → 방출 정책은 경우에 맞게 적용 가능



### 📚 콘텐츠 전송 네트워크(CDN)
---
  - 정적 콘텐츠를 전송하는데 쓰이는, 지리적으로 분산된 서버의 네트워크
  - 이미지, 비디오, CSS, JavaScript 파일 등을 캐시할 수 있다.
  - 사용자가 웹사이트를 방문하면, 그 사용자에게 가장 가까운 CDN 서버가 콘텐츠를 전달하게 된다.
     → CDN 서버와의 거리가 멀 수록 웹사이트는 천천히 로드될 것이다.

#### 🎈 사용자 요청 처리 흐름
  - 사용자 A가 이미지 URL을 이용하여 image.png에 접근
    
    → URL 도메인은 CDN 서비스 사업자가 제공
    
  - CDN 서버의 캐시에 해당 이미지가 없는 경우, 원본 서버에 요청하여 파일을 가져온다
    
    → 원본 서버는 웹 서버 또는 아마존S3 같은 온라인 저장소
  - 원본 서버가 파일을 CDN 서버에 반환
    
    → 응답의 HTTP 헤더에는 해당 파일의 TTL 값이 들어있다.
  - CDN 서버는 파일을 캐시하고 사용자 A에게 반환
  - 사용자 B가 같은 이미지에 대한 요청을 CDN 서버에 전송
  - 만료되지 않은 이미지에 대한 요청은 캐시를 통해 처리
    > TTL : Time-To-Live 의 약자로 객체의 수명을 나타냄
    >

#### 🎈 CDN 사용시 고려할 점
  - 비용
    
    - 자주 사용되지 않는 콘텐츠를 캐싱하는 것은 이득이 크지 않음
  - 적절한 만료 시한
    - 너무 길지도 짧지도 않아야함
  - CDN 장애에 대한 대처 방안
    - CDN 자체가 죽었을 경우 웹/앱 어플리케이션이 어떻게 동작할지 고려
    - 일시적으로 CDN이 응답하지 않을 경우, 원본 서버로부터 직접 컨텐츠를 가져오도록 해야할 수도 있다.
  - 콘텐츠 무효화 방법
    - 아직 만료되지 않은 콘텐츠도 CDN에서 제거 할 수 있다.
      
      → CDN 서비스 사업자가 제공하는 API를 이용하여 콘텐츠 무효화
      
      → 콘텐츠의 다른 버전을 서비스 하도록 오브젝트 비저닝을 이용
      
      → URL 마지막에 버전 번호를 인자로 주어 사용 Ex) image.png?v=2


### 📚 무상태(Stateless) 웹 계층
--- 
  - 웹 계층을 수평적 확장하기 위해선 상태 정보를 웹 계층에서 제거해야함
  - 상태 정보를 DB같은 지속성 저장소에 보관 후 사용

#### 🎈 상태 정보 의존적인 아키텍쳐
  - 같은 클라이언트로부터의 요청은 항상 같은 웹 서버로 전송되어야함.
  - 대부분의 로드밸런서가 이를 지원하기 위해 고정세션 기능을 제공 하지만 성능 저하 유발
    
    → 로드밸런서 뒷단에 서버 추가 및 제거가 까다로워짐

#### 🎈 무상태 웹 계층
  - 클라이언트의 요청이 어떤 웹 서버로 전달 될 수 있다.
  - 웹 서버는 상태 정보가 필요한 경우 공유 저장소로부터 데이터를 가져온다.

    → 공유 저장소의 경우 RDB, 캐시 시스템(Redis), NoSQL 모두 사용가능


### 📚 데이터 센터
---
  - 가용성을 높이고 전 세계 어디서도 쾌적하게 사용할 수 있도록 하기위해선 여러 데이터 센터를 지원하는것이 필수

#### 🎈 다중 데이터센터 기술적 난제

  - 트래픽 우회
    
    - 올바른 데이터센터로 트래픽을 보내는 효과적인 방법을 찾아야한다.
      
      > 지리적 라우팅 : 장애가 없는 상황에서 사용자는 가장 가까운 데이터 센터로 안내된다.
      
      > geoDNS : 지리적 라우팅에서 사용자의 위치에 따라 도메인 이름은 어떤 IP 주소로 변환할지 결정하는 DNS 서비스
      >

  - 데이터 동기화
    - 데이터 센터마다 별도의 DB를 사용한다면, 장애가 복구되어도 해당 서버의 DB에 찾는 데이터가 없을 수 있다.

      → 보편적으로 데이터를 여러 데이터센터에 걸쳐 다중화 한다.
      
  - 테스트와 배포
    - 여러 데이터 센터를 사용하도록 시스템이 구성된 상황이라면 웹사이트 또는 어플을 여러위치에서 테스트 해보는 것이 좋다.

      → 배포 자동화로 모든 데이터센터에 동일한 서비스 설치


### 📚 메시지 큐
---
  - 큰 큐모로 시스템 확장하기 위해 시스템 컴포넌트를 분리하여 각각 독립적 확장을 추구하기위한 핵심 전략
  - 메시지의 무손실을 보장, 비동기 통신을 지원하는 컴포넌트이며 버퍼 역할을 한다.
  - 메시지 큐 이용시, 서비스 또는 서버 간 결합이 느슨해져 규모 확장성 보장을 확보하고 안정적 어플리케이션 구성에 용이
  - 생산자와 소비자가 서로의 상태에 상관없이 메시지를 발행 또는 수신할 수 있음.

#### 🎈 로그, 메트릭 그리고 자동화
  - 소규모 웹 사이트를 만들 때는 로그나 매트릭, 자동화가 꼭 필요한 것은 아니지만 대규모로 갈수록 더욱 유용하다.

  - 로그
    - 에러 로그는 서버 단위로 모니터링 할 수도 있지만, 로그를 단일 서비스로 모아주는 도구를 활용하면 편리하고 좋다.
  - 메트릭
    - 사업 현황에 관한 유용한 정보 및 시스템 현재 상태 파악에 용이
      - 호스트 단위 메트릭 : CPU, 메모리, 디스크 I/O
      - 종합 메트릭 : 데이터베이스 계층의 성능, 캐시 계층의 성능
      - 핵심 비즈니스 메트릭 : 일별 능동 사용자, 수익, 재방문
  - 자동화
    - CI를 도와주는 도구를 활용하면 개발자가 만드는 코드가 어떤 검증 절차를 자동으로 거치도록 할 수 있어서 문제를 쉽게 감지할 수 있다.
    - 빌드, 테스트, 배포 등의 절차를 자동화 하면 개발 생산성이 크게 향상된다.
      
      > CI : 지속적 통합(Continuous Integration)
      >

### 📚 DB의 확장
---
  - 수직적 확장(Scale Up)
    - 기존 서버에 더 많은 고성능의 자원(CPU, RAM)을 증설하는 방법
    - DB 서버 하드웨어에는 한계가 있다.
    - SPOF 의 위험성
    - 고성능 서버로 갈수록 비용 증가
   
  - 수평적 확장(sharding)
    - 기존 서버에 더 많은 서버를 추가하는 방법
    - 데이터베이스를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술
    - 모든 샤드는 같은 스키마를 쓰지만 샤드에 보관된 데이터 사이에는 중복이 없다.
    - Ex) user_id % 4 

#### 🎈 샤딩 전략 구현시 고려할 점

  - 샤딩 키 (파티션 키)
    - 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼
    - 샤딩 키를 정할 때는 데이터를 고르게 분할 할 수 있도록 하는것이 중요하다.
      
  - 데이터의 재 샤딩이 필요한 경우
    - 데이터가 너무 많아져 하나의 샤드로는 감당하기 어려울때
    - 샤드 소진 현상이 발생하면 샤드 키 계산 함수를 변경하고 데이터를 재배피 하여야함

      → 안정 해시 기법을 활용하여 해결가능
      
      > 샤드 소진 : 특정 샤드에 할당된 공간소모가 다른 샤드에 비해 빨리 진행되는 현상
      >
  - 유명인사(핫스팟 키) 문제
    - 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제
    - Ex) 유명인사들이 전부 모여있는 샤드는 Read 연산 과부하를 유발할 수 있다.
      
  - 조인과 비정규화
    - 여러 샤드에 걸친 데이터를 조인하기가 힘들어진 데이터베이스를 비정규화하여 하나의 테이블에서 질의가 수행될 수 있도록 하는 것이다.
