## 🌈 Chapter 5 : 안정 해시 설계
<details><summary>정리</summary>
  
  ```
  안정 해시의 이점은 다음과 같다.
  - 서버가 추가되거나 삭제될 때 재배치 되는 키의 수가 최소화 된다.
  - 데이터가 보다 균등하게 분포하게 되므로 수평적 규모 확장성을 달성하기 쉽다.
  - 핫스팟 키 문제를 줄인다.
    - 특정한 샤드에 대한 접근이 지나치게 빈번하면 서버 과부하 문제가 생길 수 있다.
    - 안정 해시는 데이터를 좀 더 균등하게 분배한다.
    - Ex) 유명인사 문제
  - 안정 해시의 유명한 몇 가지 사례는 다음과 같다.
    - AWS DynamoDB의 파티셔닝 관련 컴포넌트
    - Apache Cassandra 클러스터에서의 데이터 파티셔닝
    - Discord 채팅 애플리케이션
    - Akamai CDN
    - Meglev 네트워크 부하 분산기
```
    
</details>

- 수평적 규모 확장성을 달성하기 위해서는 요청이나 데이터를 서버에 균등하게 나눠야한다.
- 보편적으로 이것을 위해 안정 해시를 사용한다.

### 📚 해시 키 재배치(rehash) 문제
---
- serverIndex = hash(key) % N (서버의 개수)
- 예제 : 총 4대의 서버
  > - 서버가 4대 일때
  > <img src = "https://github.com/Songdoeon/Book_Study/assets/96420547/1372bcc8-681c-4e5f-9dda-ddde2bb89a85" width = "800" height = "400">
  >
  > - 서버 장애로 서버풀이 3개로 변했을 경우
  > <img src = "https://github.com/Songdoeon/Book_Study/assets/96420547/03220a37-a6d2-4341-8260-bd5e7916b4a4" width = "800" height = "400">
  > 
- 장애가 발생한 서버 키 뿐만 아니라 대부분의 키가 재분배 된다.
- 대부분의 캐시 클라이언트가 데이터가 없는 엉뚱한 서버에 접속하게 된다.
- 안정 해시는 이러한 대규모 캐시 미스 발생을 효과적으로 해결한다.

### 📚 안정 해시
---
- 안정 해시 : 해시 테이블 크기가 조정될 때 평균적으로 오직 k / n개의 키만 재배치하는 해시 기술
- 대부분의 전통적 해시 테이블은 슬롯의 수가 바뀌면 거의 대부분의 키를 재배치한다.
  > k : 키의 개수
  
  > n : 슬롯의 개수

#### 🎈 안정 해시 동작 원리
- 동작 원리
  - 해시 함수를 정하고 해시 공간의 양쪽을 구부려 해시 링으로 만든다.
  - 해시 서버와 해시 키를 해시 링 위에 배치한다
  - 어떤 키가 저장되는 서버는 해당 키의 위치에서 시계 방향으로 링을 탐색해 만나는 첫 번째 서버다.
    <img src = "https://github.com/Songdoeon/Book_Study/assets/96420547/96fbbb05-f3b2-43e8-ac82-dd2d04d1debc" width = "800" height = "500">
- 서버 추가
  - 서버를 추가하더라도 키 가운데 일부만 재배치 하면 된다.

- 서버 제거
  - 하나의 서버가 제거되면 키 가운데 일부만 재배치 된다.
 
#### 🎈 기본 구현법의 두 가지 문제
- 안정 해시 알고리즘의 기본 절차
  - 서버와 키를 균등 분포 해시 삼수를 사용해 해시링에 배치한다.
  - 키의 위치에서 링을 시계 방향으로 탐색하다 만나는 최초의 서버가 키가 저장될 서버다.
 
- 서버의 추가 또는 삭제시 파티션 크기를 균등하게 유지하는 게 불가능 하다.
  <img src = "https://github.com/Songdoeon/Book_Study/assets/96420547/fb9c4b42-625a-4005-aee6-65bd5202c8dc" width = "800" height = "500">
  
  - 서버간 할당 받는 해시 공간 크기 차이가 심해질 수 있다.
- 키의 균등 분포를 달성이 어렵다.
  <img src = "https://github.com/Songdoeon/Book_Study/assets/96420547/5440fed6-be3a-41e0-9627-3486c788707c" width = "800" height = "500">
  - 서버1 과 서버 3은 아무런 데이터도 갖지 않는 반면, 대부분의 키는 서버 2에 보관될 것이다.

- 이 문제를 해결하기 위해 제안된 기법이 가상 노드(virtual node) 또는 복제(replica)라 불리는 기법이다.

#### 🎈 가상 노드
가상 노드(virtual node)는 실제 노드 또는 서버를 가리키는 노드로서, 하나의 서버는 링 위에 여러 개의 가상 노드를 가질 수 있다.

- 예제 : 서버2개가 각각 3개의 가상노드를 가지고 있다.
  <img src = "https://github.com/Songdoeon/Book_Study/assets/96420547/cb0394f7-1a17-4219-9c0e-0646a19deaa7" width = "800" height = "500">

- 가상 노드를 늘리면 키의 분포는 점점 더 균등해진다.

  → 표준 편차가 작아져 데이터가 고르게 분포되기 때문이다.

  → 100~200개의 가상 노드를 사용 했을 경우 표준 편차 값은 평균의 5%(200개) 에서 10%(100개) 사이다.
- 가상 노드의 개수를 더 늘리면 표준 편차 값은 더 떨어진다.

  → 그러나 가상 노드 데이터를 저장할 공간은 어 많이 필요하게 될 것이다.

  → 시스템 요구사항에 맞도록 가상 노드 개수를 적절히 조정해야 한다.
