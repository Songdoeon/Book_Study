## 🌈 Chapter 18 : 함수형 관점으로 생각하기
우리는 **함수형**이라는 용어를 많이 언급했다.

람다, 일급 함수와 관련있으며 때로는 객체 변화를 제한하는 것이 함수형과 밀접한 관련을 갖는다.   
그럼 이 함수형의 장점이 무엇일까?


## 📚 LESSEN 1 : 시스템 구현과 유지보수
동시성 버그를 고치는 일은 매우 어렵다.   
그렇기에 대규모 소프트웨어 시스템 업그레이드 관리에서는 `synchronized`로 인해 유지보수가 엄청 어려워진다.

단, 자바 8의 스트림을 이용하면 잠금 문제를 신경쓰지 않아도 되지만 스트림은 상태없는 동작이라는 조건이 있다.

그럼 유지보수하기 좋은 프로그램은 어떤 모습일까?
- 프로그램이 시스템의 구조를 이해하기 쉽게 클래스 계층으로 반영
- 다음 두 가지 소프트웨어 엔지니어링 도구로 프로그램 구조를 평가할 수 있다.
  - 시스템의 각 부분의 상호 의존성을 가리키는 결합성
  - 시스템의 다양한 부분이 서로 어떤 관계를 갖는지 가리키는 응집성

### 🎈 공유된 가변 데이터
변수가 예상하지 못한 값을 갖는 이유는 결국 우리가 유지보수하는 시스템의 여러 메서드에서    
공유된 가변 데이터 구조를 읽고 갱신하기 때문이다.

공유 가변 데이터 구조를 사용하면 프로그램 전체에서 데이터 갱신 사실을 추적하기 어려워진다.

![image](https://github.com/Songdoeon/Book_Study/assets/96420547/02c9fd9a-a34b-427d-ad45-ea507e89b345)

자신을 포함하는 클래스의 상태 그리고 다른 객체의 상태를 바꾸지 않으며    
return 문을 통해서만 자신의 결과를 반환하는 메서드를 **순수(pure)** 메서드 또는 **부작용 없는(side-effect free)** 메서드라 한다.

구체적으로 부작용은 무엇일까?   
함수 내에 포함되지 못한 기능을 부작용이라 한다.
- 자료구조를 고치거나 필드에 값을 할당(setter 메서드 같은 생성자 이외의 초기화 동작)
- 예외 발생
- 파일에 쓰기 등의 I/O 동작 수행

불변 객체를 이용해 부작용을 없애는 방법도 있다.    
불변 객체는 인스턴스화 이후 객체의 상태를 바꿀 수 없는 객체로 함수 동작에 영향을 받지 않는다.

따라서 불변 객체는 복사하지 않고 공유할 수 있으며, 스레드 안정성을 제공한다.

부작용 없는 시스템 컴포넌트에서는 메서드가 서로 간섭하는 일이 없으므로 
잠금을 사용하지 않고도 멀티코어 벙렬성을 사용할 수 있고 프로그램의 어떤 부분이 독립적인지 바로 이해할 수 있다.

### 🎈 선언형 프로그래밍
프로그램으로 시스템을 구현하는 방식은 크게 두 가지로 구분할 수 있다.

- 작업을 어떻게 수행할 것인지에 집중하는 방법
```java
Transaction mostExpensive = transactions.get(0);    
if(mostExpensive == null)
  throw new IllegalArgumentException("Empty list of transactions");

for(Transaction t : transactions.subList(1, transactions.size())){
  if(t.getValue() > mostExpensive.getValue()){
    mostExpensive = t;                // 리스트에서 가장 비싼 트랜잭션을 찾아 갱신함
  }
}
```
- '어떻게'가 아닌 '무엇을'에 집중하는 방식
```java
Optional<Transaction> mostExpensive = transactions.stream()
                                      .max(comparing(Transaction::getValue));
```
위와 같은 구현 방식을 내부 반복이라고 한다.   
질의문 자체로 문제를 어떻게 푸는지 명확하게 보여준다는 것이 내부 반복 프로그래밍의 큰 장점이다.

이처럼 `무엇을`에 집중하는 방식을 선언형 프로그래밍이라고 부른다.

선언형 프로그래밍에서는 우리가 원하는 것이 무엇이고 시스템이 어떻게 그 목표를 달성할 것인지 규칙을 정한다.    
문제 자체가 코드로 명확하게 드러난다는 점이 선언형 프로그래밍의 강점이다.

### 🎈 왜 함수형 프로그래밍인가?
함수형 프로그래밍은 선언형 프로그래밍을 따르는 대표적인 방식이며 pure하고 side-effect free를 지향한다.

람다와 스트림을 이용해 여러 연산을 복잡한 질의로 포현하거나 자연스러운 코드를 구현할 수 있다.

## 📚 LESSEN 2 : 함수형 프로그래밍이란 무엇인가?
함수형 프로그래밍이란 무엇인가? 라는 질문에 답변을 준비해보자.

`int`와 `double`을 인수로 받아서 double을 반환하는 메서드가 있는데 이 메서드는   
다음 그림처럼 자신이 호출된 횟수로 가변 변수를 갱신하는 부작용을 포함하고 있다.

![image](https://github.com/Songdoeon/Book_Study/assets/96420547/5e4f16c1-88fd-4b0c-9fa7-a63fdcbdf2d1)

함수형 프로그래밍에서 함수는 0개 이상의 인수를 가지며, 한개 이상의 결과를 반환하지만 부작용이 없어야한다.

그렇다면 함수형 프로그래밍에서는 함수와 if-then-else등의 수학적 표현만 사용해야 하는가?    
아니면 시스템의 다른 부분에 영향을 미치지 않는다면 내부적으로는 함수형이 아닌 가능도 사용할 수 있을까?

즉, 내부적으로만 부작용이 발생한다면 실제로 부작용이 발생한 것이라고 말할수 있을까 라는 점이다.  

호출자에게 영향이 없다면 호출자는 내부 부작용을 파악하거나 신경쓸 필요가 없다.

결론적으로 함수 그리고 수학적 표현만 사용하는 순수 함수,    
그리고 시스템의 다른 부분에 영향을 미치지 않는 내부적으로는 함수형이 아닌 기능을 사용하는 방식도 함수형 프로그래밍이다.

### 🎈 함수형 자바
실직적으로 자바로는 완벽한 순수 함수형 프로그래밍을 구현하기 어렵다.
  > 자바의 I/O 모델 자체에는 부작용 메서드가 포함됨

하지만 시스템 컴포넌트가 순수한 함수형인 것처럼 동작하도록 코드를 구현할 수 있다.     
즉, 순수 함수형이 아닌 함수형 프로그램을 구현할 것이다.

진입할 때 어떤 필드의 값을 증가시켰다 빠져나올 때 필드의 값을 돌려놓는 방식으로 구현할 것이다.   
물론 그 사이에 다른 스레드에서 필드의 값을 참조할 수 있으니 메서드의 바디를 잠금으로 문제를 해결할 것이다.

하지만 이런식으로 문제를 해결하면 프로그램 입장에서 부작용이 사라졌지만    
프로그래멋 관점에서는 프로그램의 실행 속도가 느려지게 된 것이다! ㄴㅇㄱ!!

함수형이라고 말할 수 있으려면 만족해야하는 조건이 있다.

- 함수나 메서드가 어떤 예외도 일으키지 않아야 한다.
  - 예외가 발생하면 블랙 박스 모델에서 return으로 결과를 반환할 수 없게 된다.
  - 함수형을 수학적으로 활용하는데 큰 걸림돌이다.

그럼 예외를 사용하지 않고 나눗셈 같은 함수를 어떻게 표현할까?    
바로 `Optional<T>`를 활용하는 것이다.

`double sqrt(double)` 대신 `Optional<Double> sqrt(double)`를 이용하여 예외없이 연산을 한다.
이는 귀찮은 작업으로 보일 수 있지만 모든 코드에 `Optional`를 사용하도록 반드시 고치는 것은 아니며  
함수형과 순수 함수형 프로그래밍의 장단점을 고려해 다른 컴포넌트에 영향을 미치지 않도록 지역적인 예외처리를 할 수도 있다.

마지막으로 함수형에서는 비함수형 동작을 감출 수 있는 상황에서만 부작용을 포함하는 라이브러리 함수를 사용해야 한다.
  > 자료구조를 복사한다든가 발생할 수 있는 예제를 적절하게 처리해 자료구조의 변경을 호출자가 알 수 없게해야함

### 🎈 참조 투명성
**부작용을 감춰야 한다**라는 제약은 **참조 투명성(referential transparency)** 개념으로 귀결된다.    
즉, 같은 인수로 함수를 호출하면 항상 같은 결과를 반환해야 한다는 뜻이다.



