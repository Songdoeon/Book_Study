## 🌈 Chapter 7 : 병렬 데이터 처리와 성능

자바 7 이전에는 데이터 컬렉션의 병렬처리가 까다로웠지만, 자바 7 부터는 병렬화를 수행하며 에러를 최소화 하는 **포크/조인 프레임워크** 기능을 제공한다.

이 장에서는 스트림으로 데이터 컬렉션 관련 동작을 얼마나 쉽게 병렬로 실행하는지,   
스트림을 이용한 순차 스트림의 병렬 스트림으로의 자연스러운 변환 등을 알아본다.

우선 여러 청크를 병렬로 처리하기 전에 병렬 스트림이 요소를 여러 청크로 분할하는 방법을 설명할 것이다.

이 원리를 이해하지 못하면 의도치 않은, 설명하기 어려운 결과가 발생할 수 있다.

## 📚 LESSON 1 : 병렬 스트림
4장에서 스트림을 이용해 아주 간단하게 요소를 병렬 처리가 가능하다 했다.

컬렉션에 `parallelStream`을 호출하면 **병렬 스트림**이 생성된다.
  > 병렬 스트림 : 각각의 스레드에서 처리할 수 있도록 스트림 요소를 여러 청크로 분할한 스트림

- 1 ~ N 까지의 수의 합을 반환하는 메서드
```java
public long sequentialSum(long n){
  return stream.iterate(1L, i -> i + 1)    // 무한 자연수 스트림 생성
                .limit(n)
                .retuce(0L, Long::sum);
}
```
n이 커진다면 이 연산, 병렬로 처리하는 것이 좋을 것이다.

자 그럼 병렬스트림에 대해 알아보도록 하자.

### 🎈 병렬 스트림으로 변환하기

- parallel 메서드
```java
public long sequentialSum(long n){
  return stream.iterate(1L, i -> i + 1)  
                .limit(n)
                .parallel()    // 스트림을 병렬 스트림으로 변환
                .retuce(0L, Long::sum);
}
```
이전 코드와 다른 점은 스트림이 여러 청크로 분할되어 있다는 것이다.

<img width="600" src="https://github.com/Songdoeon/Book_Study/assets/96420547/82710d87-af61-46c6-b6b0-81505e9e7d9e">

리듀싱 연산을 여러 청크에 병렬로 수행한 후 마지막 리듀싱 연산으로 생성된 부분 결과를    
다시 리듀싱 연산으로 함쳐 전체 스트림의 리듀실 결과를 도출한다.

사실 순차 스트림에 `parallel`을 호출하면 스트림이 변하는 것이 아닌 내부적으로 병렬 수행 Flag가 설정되는것이다.

반대로 `sequential`로 병렬 스트림을 순차 스트림으로 바꿀 수 있기도 하다.

두 메서드 중 최종적으로 호출된 메서드가 전체 파이프라인에 영향을 미친다.

### 📌 병렬 스트림에서 사용하는 스레드 풀 설정
병렬 스트림은 내부적으로 `ForkJoinPool`을 사용한다

기본적으로 `ForkJoinPool`은 프로세서 수, 즉 Runtime.getRuntime().availableProcessors() 가 반환하는 값에 상응하는 스레드를 갖는다.

- System.setProperty("java.util.concureent.ForkJoinPool.common.parallelism", "12")
  - 이 예제는 전역 설정 코드이므로 이후 모든 병렬 스트림 연산에 영향을 준다.
  - 현재는 하나의 병렬 스트림에 사용할 수 있는 특정한 값을 지정할 수 없다.
  - 일반적으로 기기의 프로세서 수와 같으므로 특별한 이유가 없다면 기본값을 사용하자.

### 🎈 스트림 성능 측정
병렬화를 이용하면 순차, 반복 형식에 비해 성능이 좋아질 것이다.

그러나 성능 최적화의 세 가지 규칙이 있다. 

바로 첫째도 측정, 둘째도 측정, 셋째도 측정!!

그러므로 우리는 JMH라는 자바 마이크로 벤치마크를 이용해 간단하고, 어노테이션 기반 방식으로 구현할 수 있다.

사실 JVM에서 벤치마크 작업은 쉽지 않다.   
바이트코드 최적화, 가비지 컬렉터로 인한 오버헤드 등과 같은 요소를 고려해야 하기 때문이다.

Maven등 의존성 관리 도구를 사용한다면, 의존성을 추가해 프로젝트에서 JMH를 사용할 수 있다.

