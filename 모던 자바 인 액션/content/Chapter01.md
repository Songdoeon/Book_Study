## 🌈 Chapter 1 : 자바 8, 9, 10, 11 : 무슨 일이 일어나고 있는가?

1996년 JDK 발표 이후 수많은 프로그래머, 프로젝트 관리자, 학생이 자바를 활용하기 시작했다.

자바는 처음부터 많은 유용한 라이브러리를 포함하는 잘 설계된 객체지향 언어로 시작했다.  
처음부터 스레드와 락을 이용한 소소한 동시성도 지원했으며, 코드를 JVM으로 컴파일 하는 특징 덕에 인터넷 애플릿 프로그램의 주요 언어가 되었다.

하지만 우리는 빅데이터라는 새로운 도전에 직면하며 멀티코어 컴퓨터나 컴퓨팅 클러스터를 이용해,   
빅 데이터를 효과적으로 처리할 필요성이 커졌고, 즉 병렬 프로세싱을 활용해야 하는 데 지금의 자바로는 충분히 대응 할 수 없었다.

그래서 자바8에서는 더 다양한 프로그래밍 도구 그리고 다양한 프로그래밍 문제를 더 빠르고 정확하며 쉽게 유지보수할 수 있도록 도와준다.
## 📚 LESSEN 1 : 역사의 흐름은 무엇인가?

자바 역사를 통틀어 가장 큰 변화가 자바8에서 일어났다.   
다른 버전에서의 변화도 있었지만 자바 8만큼 획기적이거나 생산성이 바뀌는 것은 아니다.

다음과 같은 코드가 있다.

```java
Collections.sort(inventory, new Comparator<Apple>() {
  public int compare(Apple a1, Apple a2){
    return a1.getWeight().compareTo(a2.getWeight());
  }
});
```
자바 8을 이용하면 자연어에 더 가깝게 간단한 방식으로 코드를 구현할 수 있다.

```java
inventory.sort(comparing(Aplle::getWeight));
```
해당 코드가 어떻게 작동하는지는 나중에 설명하겠다.

우리는 이 책을 읽으며 이 코드를 이해하고 스스로 해당 코드를 구현할 수 있도록 할 것이다.

### 🎈 자바 8의 세 가지 프로그래밍 개념

자바 8에서는 병렬 실행을 새롭고 단순한 방식으로 접글할 수 있는 방법을 제공한다.  
물론 이전 버전에서도 여러 방식이 제공되었지만 개발자가 활용하기는 쉽지 않았다.

자바 8은 간결한 코드, 멀티코어 프로세서의 쉬운 활용이라는 두 가지 요구사항을 기반으로 한다.

다음은 자바 8에서 제공하는 새로운 기술이다.
- 스트림 API
  - DB 질의 언어에서 표현식을 처리하는 것 처럼 병렬 연산을 지원하는 새로운 API
  - 에러를 최소화 하며 멀티코어 CPU를 이용하는 것보다 비용이 훨씬 비싼 synchronized를 사용하지 않아도 된다.
  - 해당 기술 덕분에 아래 두 기술이 존재한다고 볼 수도 있다.
- 메서드에 코드를 전달하는 기법
  - 새롭고 간결한 방식으로 동작 파라미터화를 구현할 수 있다.
  - 처음 나온 예제 코드가 해당 예시이다.
- 인터페이스의 디폴트 메서드

위 기술들을 기반으로 자세히 살펴보자.

### 📕 스트림 처리
첫 번째 프로그래밍 개념은 스트림 처리다.
  > 스트림 : 한 번에 한 개씩 만들어지는 연속적인 데이터 항목들의 모임

이론적으로 프로그램은 입력 스트림에서 데이터를 한 개씩 읽고 출력 스트림으로 데이터를 한 개씩 기록한다.   
즉 어떤 프로그램의 출력 스트림은 다른 프로그램의 입력 스트림이 될 수 있다.

스트림 API의 핵심은 기존에는 한 번에 한 항목을 처리했지만  
이제는 우리가 하려는 작업을 고수준으로 추상화하여 일련의 스트림으로 만들어 처리할 수 있다는 것이다.

또한 스트림 파이프라인을 이용해 입력 부분을 여러 CPU 코어에 쉽게 할당할 수도 있다.  
스레드라는 복잡한 작업을 하지 않으면서도 공짜로 병렬성을 얻을 수 있는 말이다.

### 📕 동작 파라미터화로 메서드에 코드 전달하기
자바 8에 추가된 두 번째 프로그램 개념은 코드 일부를 API로 전달하는 기능이다.

처음 보였던 코드처럼 comparator 객체를 만들어 sort에 넘겨주는 방법도 있지만,   
이는 너무 복잡하며 기존 동작을 단순 재활용 한다는 측면에서도 좋지 못하다.

<img width="500" alt="image" src="https://github.com/Songdoeon/Book_Study/assets/96420547/5451a050-3b68-46e4-a3c6-1a7d56a110e4">

위 그림은 동작 파라미터의 개념을 잘 보여준다.

`compareUsingCustomerId`를 이용해 sort의 동작을 파라미터화 했던 것처럼   
스트림 API는 연산의 동작을 파라미터화할 수 있는 코드를 전당한다는 사상에 기초하기 때문이다.

더 자세한 기술은 앞으로 차차 설명하도록 하겠다.

### 📕 병렬성과 공유 가변 데이터
세 번째 프로그래밍의 개념은 `병렬성을 공짜로 얻을 수 있다`는 말에서 시작된다.   
하지만 병렬성을 얻기위해선 스트림 메서드로 전달하는 코드의 동작 방식을 조금 바꿔야 한다.

스트림 메서드로 전달하는 코드는 다른 코드와 동시에 실행하더라고 안전하게 실행될 수 있어야 한다.  
이를 위해 공유된 가변 데이터에 접근하지 않아야 한다.

이러한 함수를 순수(pure) 함수, 부작용 없는(side-effect-free) 함수, 상태 없는(stateless) 함수라 부른다.

#### 📌 공유된 변수나 객체가 있으면 어떻게 해야할까?
- 기존처럼 synchronized를 이용하여 데이터를 보호하는 규칙을 만들 수 있다.
  - 일반적으로 synchronized는 시스템 성능에 악영향을 미친다.
- 스트림을 활용하면 기존 자바 스레드 API보다 쉽게 병렬성을 활용할 수 있따.
- 다중 프로세싱 코어에서 synchronized를 사용하면 훨씬 더 비싼 대가를 치러야 할 수 있다.
  - 다중 처리 코어에서는 코드가 순차적으로 실행되어야 하므로 병렬을 무력화 시킴

### 🎈 자바 함수
프로그래밍 언어에서 함수라는 용어는 메서드 특히 정적 메서드와 같은 의미로 사용된다.

프로그래밍 언어의 핵심은 값을 바꾸는 것이다. 전통적으로 프로그래밍 언어에서는 기본값, 인스턴드를 일급(first-class) 값(또는 시민)이라고 부른다.  
메서드 및 클래스는 이급 시민으로 분류가 되었는데 이유는 프로그램 실행동안 구조체를 자유롭게 전달할 수 없다는 것이었다.

하지만 자바 8에서는 이급 시민을 일급 시민으로 바꾸는 기능을 추가했고, 런타임에도 메서드를 전달할 수 있게 되었다.

### 📕 메서드와 람다를 일급 시민으로
메서드 참조라는 새로운 자바 8의 기능을 소개한다.  

아래 예제를 살펴보자.

```java
File[] hiddenFiles = new File(".").listFiles(new FileFilter() {
  public boolean accept(File file) {
    return file.isHidden();
  }
}
```
해당 코드는 숨겨진 파일을 찾는 메서드이다. 하지만 완성된 코드가 불편하다.

File 클래스에는 이미 isHidden이라는 메서드가 있는데 굳이 FilerFilter로 isHidden을 감싼 다음 FileFilter를 인스턴스화해야 할까?

```java
File[] hiddenFiles = new File(".").listFiles(File::isHidden);
```
아주 마음에 드는 코드다.

이미 isHidden이라는 함수가 준비되어 있기에 자바 8의 메서드 참조를 이용하여 listFiles에 직접 전달할 수 있다.  
여기선 메서드가 아닌 함수라는 용어를 사용했다는 것을 주목하고 자세한 작동법은 천천히 설명 할 것이다.

### 📕 람다 : 익명함수
자바 8에서는 메서드를 일급값으로 취급하며, 람다(익명 함수)를 포함하여 함수도 값으로 취급할 수 있다.

예를들어 `(int x) -> x + 1` 은 `x`라는 인수를 호출하면 `x + 1`로 반환 하는 동작을 수행하도록 코드를 구현할 수 있다.

물론 클래스 내부 메서드를 이용해서 File::isHidden 같은 방식으로 이용할 수도 있지만,   
이용할 클래스나 메서드가 없다면 새로운 람다 문법을 이용하여 간결하게 코드 구현이 가능하다.

  > 예를 들면 우선순위 큐 구현시 클래스에 comparable을 구현하여 사용할 수도 있지만,  
  > PriorityQueue<>((o1, o2) -> o1.cost - o2.cost))로도 정렬이 가능하다.

그리고 메서드를 값으로 전달하는 것은 분명 유용한 기능이지만 한두 번 사용할 메서드를 매번 정의하는 것은 귀찮은 일이다.
```java
filterApples(inventory, (Apple a) -> GREEN.equals(a.getColor()));
filterApples(inventory, (Apple a) -> a.getWeight() > 150);
filterApples(inventory, (Apple a) -> a. getWeight() < 80 || RED.equals(a.getColor()));
```
그렇기에 자바에서는 위처럼 람다라는 새로운 개념을 이용하여 코드를 구현할 수 있도록 마련해두었다.

하지만 람다가 몇 줄 이상으로 길어진다면 람다보다는   
코드가 수행하는 일을 잘 설명하는 이름을 가진 메서드를 정의하고 참조하도록 하는것이 바람직하다.

### 🎈 스트림
스트림 API를 이용하면 컬렉션 API와는 상당히 다른 방식으로 데이터를 처리할 수 있다.

컬렉션에서는 반복을 for-each 루프를 이용해 각 요소를 반복하며 작업을 수행했고  
이러한 방식을 외부 반복이라 한다.   

반면 스트림 API는 루프를 신경 쓸 필요없이 라이브러리 내부에서 모든 데이터가 처리된다.  
이러한 방식을 내부 반복이라 한다.

### 📕 멀티스레딩은 어렵다.
이전 버전의 자바에서 제공하는 스레드 API로 멀티스레딩 코드를 구현해 병렬성을 이용하는 것은 쉽지 않다.

하지만 스트림은 컬렉션을 처리하며 발생하는 모호함과 반복적인 코드 문제, 멀티코어 활용 어려움 이라는 두가지 문제를 모두 해결했다.

기존 컬렉션에서는 데이터 처리시 반복되는 패턴이 너무 많았고,  
따라서 라이브러리에서 이런 반복 패턴을 제공하여 주어진 조건에 따라 데이터를 필터링 하거나 추출, 그룹화하는 등의 기능이 추가되었다.

스트림 API와 컬렉션 APU는 비슷한 방식으로 동작하지만 컬렉션은 어떻게 데이터를 저장하고 접근할지 중점을 둔다면,  
스트림은 데이터에 어떤 계산을 할 것인지에 중점을 둔다는 점을 기억하자.

컬렉션을 필터링할 수 있는 가장 빠른 방법은 컬렉션을 스트림으로 바꿔 병렬 처리 이후 리스트로 다시 복원하는 것이다.

다음은 병렬 처리 스트림의 코드다.
```java
import static java.util.stream.Collectors.toList;
List<Apple> heavyApples =
  inventory.parallelStream().filter((Apple a) -> a.getWeight() > 150)
                            .collect(toList());
```
    > filter같은 경우는 병렬 처리시 유의미한 성능 차이가 있지만 sorted의 경우는 병렬처리가 그다지 도움되지 않는다.

### 🎈 디폴트 메서드
자바의 변화 과정에서 자바8 개발자들이 겪는 어려움 중 하나는 기존 인터페이스의 변경이다.

예를 들어 Collections.sort는 사실 List 인터페이스에 포함되지만 실제로 List로 포함된 적은 없다.   
이론적으로는 `Collection.list(list, comparator)`가 아니라 `list.sort(comparator)`를 수행하는 것이 적절하다.

인터페이스 업데이트시 해당 인터페이스를 구현하는 모든 클래스도 업데이트 해야했지만  
자바 8의 디폴트 메서드로 이 문제를 해결할 수 있다.

### 📕 자바 모듈
요즘은 외부 컴포넌트를 이용해 시스템을 구축하는 경향이 있다.

이와 관련해 지금까지 자바에서는 특별한 구조가 아닌 JAR 파일을 제공하는 것이 전부였다.  
이러한 패키지의 인터페이스를 바꿔야 하는 상황에서는 인터페이스 구현 클래스의 구현을 모두 다 바꿔야 했으므로 여간 힘든게 아니였다.

자바8, 자바9는 이 문제를 다음과 같은 방법으로 해결한다.  
우선 자바 9의 모듈 시스템은 모듈을 정의하는 문법을 제공하므로 이를 이용해 패키지 모음을 포함하는 모듈을 정의할 수 있다.

모듈 덕분에 JAR 같은 컴포넌트에 구조를 적용할 수 있으며, 문서화와 모듈 확인 작업이 용이해졌다.

### 📕 디폴트 메서드
또한 자바 8에서는 인터페이스를 쉽게 바꿀 수 있도록 디폴트 메서드를 지원한다.

하지만 프로그래머가 직접 디폴트 메서드를 구현하는 상황은 흔치 않다.  
디폴트 메서드는 특정 프로그램을 구현하는 데 도움을 주는 기능이 아니라 프로그램이 미래에 쉽게 변화할 수 있는 환경을 제공하는 기능이기 때문이다.

예를 들어 이전에는 List나 Collection 인터페이스는 stream이나 parallelStream 메서드를 지원하지 않았다.  
하지만, Collection 인터페이스에 stream 메서드를 추가한다면 수많은 컬렉션 API의 구현체들에 전부 새로운 메서드를 추가해야할 것이다.

하지만 디폴트 메서드로 stream을 추가할 경우 구현체에서 메서드를 추가할 필요가 없고,  
인터페이스 설계를 자유롭게 확장할 수 있게 되었다.

### 🎈 함수형 프로그래밍에서 가져온 다른 유용한 아이디어
우리의 개발에 발목을 자주 붙잡는 NullPointException은 Runtime Exception으로 피하기가 쉽지 않다.

하지만 자바 8에서 부턴 Optional<T> 클래스로 NPE를 피할 수 있도록 도와준다.
