## 🌈 Chapter 4 : 스트림 소개
<details><summary>정리</summary>
  
  ```
  - 스트림은 소스에서 추출된 연속 요소로, 데이터 처리 연산을 지원한다.
  - 스트림의 내부 반복의 특성으로 인해 얻는 이점이 많다.
  - 내부 반복은 filter, map, sorted 등의 연산으로 반복을 추상화 한다.
  - 스트림의 중간 연산은 스트림을 반환하여 파이프라인을 구성할 수 있지만 어떤 결과도 생성할 수 없다.
  - 스트림의 최종 연산은 for-each, count 등 파이프라인을 처리해 결과를 반환해준다.
  ```

</details>

대부분의 자바 애플리케이션은 컬렉션을 만들고 처리하는 과정을 포함한다.

컬렉션으로 데이터를 그룹화하고 처리할 수 있기 때문인데 컬렉션 관련 연산은 어떻게 이용할까?

## 📚 LESSEN 1 : 스트림이란 무엇인가?
스트림(Stream)은 자바 8 API에 새로 추가된 기능이다.

스트림을 이용하면 선언형으로 컬렉션 데이터를 처리할 수 있다.   
또한 멀티스레드 코드를 구현하지 않아도 데이터를 투명하게 병렬로 처리할 수 있다.

### 🎈 스트림
다음은 스트림의 예제를 보여주겠다.

- 자바 8 이전의 코드
```java
List<String> lowCaloricDishesName = new ArrayList<>();

for(Dish dish : menu){
  if(dish.getCalories() < 400{
    lowCaloricDishes.add(dish.getName());
  }
}
```
- 자바 8 코드
```java
List<String> lowCaloricDishesName =
                            menu.stream()
                              .filter(d -> d.getCalories() < 400)    // 400칼로리 이하 선택
                              .sorted(comparing(Dish::getCalories))  // 칼로리로 요리 정렬
                              .map(Dish::getName)                    // 요리명 추출
                              .collect(toList());                    // 모든 요리명을 리스트에 저장
```

stream은 parallelStream 으로 호출하여 사용할 수도 있지만 정확한 일은 다음에 다루도록 하겠다.

### 🎈 스트림의 특징
스트림은 사실 매우 비싼 연산이다.    
앞에서 병렬성을 공짜로 얻는다고 말했지만 단일 쓰레드의 경우에는 for문 반복보다 월등히 성능이 낮은 모습을 보여준다.

특정경우에서 stream연산이 아주 조금 더 효율적이라고 하지만 극히 드문일일것이다.

하지만 그럼에도 stream을 사용하는 이유는 무엇일까?   
자바 8의 스트림 API의 특징을 다음처럼 요약할 수 있다.

- **선언형** : 더 간결하고 가독성이 좋아진다.
- **조립성** : 유연성이 좋아진다.
- **병렬화** : 성능이 좋아진다.
  

## 📚 LESSEN 2 : 스트림 시작하기
스트림이란 정확히 뭘까?


### 🎈 스트림 연산 특징
스트림이란 데이터 처리 연산을 지원하도록 소스에서 추출된 연속된 요소로 정의할 수 있다.   
이 정의를 하나씩 살펴보자.

- **연속된 요소**
  - 컬렉션과 마찬가지로 특정 요소 형식으로 이루어진 연속된 값 집합의 인터페이스를 제공한다.
  - 컬렉션은 시간과 공간의 복잡성과 관련 요소 저장 및 접근 연산이 주를 이룬다
  - 반면 스트림은 filter, sorted, map 처럼 표현 계산식이 주를 이룬다.
  - 즉 컬렉션의 주제는 데이터, 스트림의 주제는 계산이다.
- **소스**
  - 스트림은 컬렉션, 배열, I/O 자원 등의 데이터 제공 소스로부터 데이터를 소비한다.
  - 정렬된 컬렉션으로 스트림을 생성하면 그대로 유지된다.
  - 즉 스트림은 리스트의 요소를 유지한다.
- **데이터 처리 연산**
  - 스트림은 함수형 프로그래밍 언어에서 일반적으로 지원하는 연산과 데이터베이스와 비슷한 연산을 지원한다.
  - Ex)filter, map, reduce, find, match, sort 등으로 데이터 조작 가능
  - 스트림 연산은 순차적, 병렬 모두 실행 가능하다.
- **파이프라이닝**(Pipelining)
  - 대부분의 스트림 연산은 스트림 연산끼리 연결해서 커다란 파이프라인을 구성할 수 있도록 스트림 자신을 반환한다.
  - 그 덕분에 lazy, short-circuiting같은 최적화도 얻을 수 있다.
  - 연산 파이프라인은 데이터 소스에 적용하는 데이터베이스 질의와 비슷하다.
- **내부 반복**
  - 반복자를 이용해 명시적 반복을 진행하는 컬렉션과 달리 스트림은 내부 반복을 지원한다.

스트림의 데이터 소스는 연속된 요소를 스트림에 제공한다.   
그 방식을 이용해 filter, map, limit 등으로 이어지는 데이터 처리 연산을 적용한다.

스트림의 중간 연산들은 서로 파이프라인을 형성할 수 있도록 스트림을 반환하며,  
최종 연산으로 파이프라인을 처리해 결과를 반환한다.

즉 최종 연산을 호출하기 전까지 메서드 호출이 저장되는 효과가 있다.

## 📚 LESSEN 3 : 스트림과 컬렉션
자바의 기존 컬렉션과 새로운 스트림 모두 연속된 요소 형식의 값을 저장하는   
자료구조의 인터페이스를 제공한다.

여기서 **연속된**이라는 표현은 순서와 상관없이 아무 값에나 접속하는 것이 아니라 순차적으로 값에 접근한다는것이다.

이제 컬렉션과 스트림의 차이를 살펴보자

### 🎈 스트림과 컬렉션의 차이
DVD와 인터넷 스트리밍으로 예를 들어보겠다.

일단 DVD에 어떤 영화가 저장되어 있다.   
DVD에 전체 자료구조가 저장되어 있으므로 컬렉션이다.

- DVD
  - 처음부터 모든 데이터가 DVD에 담겨있음
- 인터넷 스트리밍
  - 사용자가 시청하는 부분의 몇 프레임만 미리 내려받는다.
  - 다른 대부분의 값을 처리하지 않은 상태에서 미리 받은 부분 프레임 부터 재생
 
둘 차이의 큰 특징은 데이터를 **언제** 계산하느냐 이다.

컬렉션은 모현재 자료구조가 포함하는 모든 값을 메모리에 저장하는 자료구조다.  
즉, 컬렉션의 모든 요소는 컬렉션 추가 전 계산되어야 한다.

반면 스트림은 이론적으로 **요청할 때만 요소를 계산**하는 고정된 구조다.  
이러한 특징은 프로그래밍에 큰 도움을 준다.

### 🎈 딱 한 번만 탐색할 수 있다.
반복자와 마찬가지로 스트림도 한 번만 탐색할 수 있다.  
즉 탐색된 스트림의 요소는 소비된다.

한 번 탐색한 요소를 다시 탐색하려면 초기 데이터 소스에서 새로운 스트림을 만들어야 한다.

### 🎈 외부 반복과 내부 반복
컬렉션 인터페이스를 사용하려면 사용자가 직접 요소를 반복해야 한다.  
이를 외부 반복이라고 한다.

반면 스트림 라이브러리는 내부 반복을 사용한다.   
함수에 어떤 작업을 수행할지만 지정하면 모든 것이 알아서 처리된다.

예제를 통해 살펴보자.

- 컬렉션 : for-each 루프를 이용하는 외부 반복
```java
List<String> names = new ArrayList<>();

for(Dish dish : menu){    // 메뉴 리스트를 명시적으로 순차 반복한다.
  names.add(dish.getName());    // 이름 추출후 리스트에 추가
}
```
- 스트림 : 내부 반복
```java
List<String> names = menu.stream()
                    .map(Dish::getName)        // map 메서드를 getName 메서드로 파라미터화
                    .collect(toList());        // 파이프라인을 실행한다. 반복자 필요 X
```

내부 반복이 더 좋은 이유는 두 가지 정도가 있다.

- 작업을 투명하게 병렬로 처리하거나 더 최적화된 다양한 순서로 처리할 수 있다.
  - 외부 반복으로 처리시 위와 같은 이유로 최적화를 달성하기 어렵다.
- 내부 반복은 데이터 표현과 하드웨어를 활용한 벙렬성 구현을 자동으로 선택한다.
  - 외부 반복에서는 병렬성을 스스로 관리해야함.

다음 그림은 내부 반복과 외부 반복의 차이를 보여준다.

<img width="554" alt="image" src="https://github.com/Songdoeon/Book_Study/assets/96420547/8cafb77f-d815-449b-9aa1-071eec285ecc">


## 📚 LESSEN 4 : 스트림 연산
java.util.stream.Stream 인터페이스는 많은 연산을 정의한다.

스트림 연산은 아까 말했듯 중간연산과 최종 연산 두가지로 나눌 수 있다.

### 🎈 중간 연산
스트림 중간 연산은 스트림을 반환하며 스트림 파이프라인을 구성한다.
중간 연산자들을 소개하며 특징들을 소개하겠다.

- filter
  - 람다를 인수를 받아 스트림에서 특정 요소를 제외시킨다.
  - Ex) `filter(d -> d.getCalories() > 400)`
- map
  - 한 요소를 다른 요소로 변환하거나 정보를 추출한다.
  - Ex) `map(Dish::getName)`, `map(d -> d.getName())`
- limit
  - 정해진 개수 이상의 요소가 스트림에 저장되지 못하게 스트림의 크기를 정한다.
- sorted
  - 스트림 요소들을 정렬한다.

스트림의 lazy한 특성으로 몇 가지 최적화 효과를 얻을 수 있다.

바로 filter로 걸러지는 요소가 여러개여도 limit 연산으로 인해 몇개만 선택된다.   
이는 쇼트서킷이라 불리는 기법 덕분이다. (뒤에서 자세히 설명함)

그리고 filter와 map은 서로 다른 연산이지만 한 과정으로 병합된다.   
이를 루프 퓨전이라고 한다.

### 🎈 최종 연산
최종 연산은 스트림 파이프라인에서 결과를 도출한다.

보통 최종 연산에 의해 List, Integer, void등 결과가 반환된다.


<img width="731" alt="image" src="https://github.com/Songdoeon/Book_Study/assets/96420547/d23f8892-2da1-4c84-aec1-72a1b17ecea2">

