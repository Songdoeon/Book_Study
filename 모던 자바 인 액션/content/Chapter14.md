## 🌈 Chapter 14 : 자바 모듈 시스템
자바 9에서 가장 많이 거론되는 새로운 기능은 바로 모듈 시스템이라고 한다.   
모듈 시스템은 직소(Jigsaw) 프로젝트 내부에서 개발된 기능이다.   

14장에서는 모듈 시스템이란 무엇이며, 새로운 자바 모듈 시스템이 어디에 어떻게 사용되는지 설명한다.

사실 모듈 시스템은 한 권의 책으로 써야 할만큼 복잡한 주제다.   
따라서 자세한 건 니콜라이 팔로그의 `The Java Module System`을 보길 권장한다.

## 📚 LESSION 1 : 소프트웨어 유추
모듈화란 무엇인가? 모듈 시스템은 어떤 문제를 해결할 수 있는가?

지금까지 이 책은 이해하기 쉽고 유지보수하기 좋은 코드를 구현하는 새로운 기능들을 소개했다.    

하지만 이러한 부분은 저수준의 영역이고, 궁극적인 소프트웨어 아키텍처 즉 고수준에서는 기반 코드를 바꿔야 할 때     
유추하기 쉬워 생산성을 높일 수 있는 소프트웨어 프로젝트가 필요하다.

이번 절에서는 추론하기 쉬운 소프트웨어에 도움을 주는 **관심사 분리** 그리고 **정보 은닉**을 살펴본다.

### 🎈 관심사 분리
관심사 분리(Separation of concerns)는 컴퓨터 프로그램을 고유의 기능으로 나누는 동작을 권장하는 원칙이다.

다양한 형식으로 구성된 지출을 파싱, 분석한 다음 결과를 고객에게 요약 보고하는 회계 어플리케이션을 개발한다고 가정한다.

SoC를 적용하여 파싱, 분석, 레포트 기능을 모듈이라는 각각의 부분, 즉 서로 거의 겹치지 않는 코드 그룹으로 분리할 수 있다.    
다시 말해 클래스를 그룹화한 모듈을 이용해 애플리케이션의 클래스 간의 관계를 시각적으로 보여줄 수 있다.

이미 자바 패키지가 클래스를 그룹으로 구분하기도 하지만,   
자바9의 모듈은 클래스가 어떤 다른 클래스를 볼 수 있는지를 컴파일 시간에 정교하게 제어할 수 있다.

SoC 원칙은 모델, 뷰, 컨트롤러 같은 아키텍처 관점 그리고 복구 기법을 비즈니스 로직과 분리하는 등의 하위 수준 접근 등의 상황에 유용하다.

SoC 원칙은 다음과 같은 장점을 제공한다.
- 개별 기능을 따로 작업할 수 있어 팀이 쉽게 협업할 수 있다.
- 개별 부분을 재사용하기 쉽다.
- 전체 시스템을 쉽게 유지보수할 수 있다.

### 🎈 정보 은닉
**정보 은닉** 은 세부 구현을 숨기도록 장려하는 원칙이다. 
 
소프트웨어를 개발할 때 요구사항은 자주 바뀐다.   
세부 구현을 숨김으로 프로그램의 어떤 부분을 바꿨을 때 다른 부분까지 영향을 미칠 가능성을 줄일 수 있다. 

즉 코드를 관리하고 보호하는 데 유용한 원칙이다.

캡슐화는 특정 코드 조각이 애플리케이션의 다른 부분과 고립되어 있음을 의미하며,    
캡슐화된 코드의 내부적인 변화가 의도치 않게 외부에 영향을 미칠 가능성이 줄어든다. 

Java에선 클래스 내의 컴포넌트에 적절하게 private 키워드를 사용했는지를 기준으로 컴파일러를 이용해 캡슐화를 확인할 수 있다.   
하지만 Java 9 이전까지는 클래스와 패키지가 의도된 대로 공개되었는지를 컴파일러로 확인할 수 있는 기능이 없었다.

## 📚 LESSION 2 : 자바 모듈 시스템을 설계한 이유
이번 절에서는 자바 언어와 컴파일러에 새로운 모듈 시스템이 추가된 이유를 설명한다.

먼저 자바 9 이전의 모듈화 한계를 살펴본 후, JDK 라이브러리와 관련한 배경 지식을 제공하고 모듈화의 중요성을 설명하겠다.

### 🎈 모듈화의 한계
자바 9 이전 모듈화엔 한계가 있었다.

자바는 클래스, 패키지, JAR 세 가지 수준의 코드 그룹화를 제공한다.   
클래스와 관련해 자바는 접근 제한자와 캡슐화를 지원했지만, 패키지와 JAR 수준에서의 캡슐화는 거의 지원하지 않았다.

#### 📕 제한된 가시성 제어
패키지 간의 가시성 제어는 어떻게 할까?

한 패캐지의 클래스와 인터페이스를 다른 패키지로 공개하려면 public으로 이들을 선언해야 한다.    
결과적으로 이들 클래스와 인터페이스는 모두에게 공개된다.

특히 기본 규현을 제공하는 의미로 **impl**이라는 문자열을 가진 패키지에서 이런 문제가 두드러진다.

이런 상황에서 보통 패키지 내부 접근자가 Public 이므로 사용자가 이 내부 구현을 마음대로 사용할 수 있다.    
내부적으로 사용할 코드를 다른 프로그래머가 임시로 사용해 정착해버릴 수 있으므로, 결국 기존 애플리케이션을 보존하며 코드를 바꾸기 어려워진다.

보안 측면에서 볼 때 코드가 노출되었으므로 코드를 임의 조작에 더 많이 노출될 수 있다.

#### 📕 클래스 경로
애플리케이션을 번들하고 실행하는 기능과 관련해 Java는 태생적으로 약점을 갖고 있다. 

클래스를 모두 컴파일한 다음 보통 한 개의 평범한 JAR 파일에 넣고 클래스 경로에 이 JAR 파일을 추가해 사용할 수 있다.    
그러면 JVM이 동적으로 클래스 경로에 정의된 클래스를 필요할 때 읽는다. 

하지만 클래스 경로와 JAR 조합에는 몇 가지 약점이 존재한다.

- 클래스 경로에는 같은 클래스를 구분하는 버전 개념이 없다.
  - 라이브러리 클래스를 지정할 때 버전을 지정할 수 없다.
  - 다양한 컴포넌트가 같은 라이브러리의 다른 버전을 사용하는 상황이 발생할 수 있다.
- 클래스 경로는 명시적인 의존성을 지원하지 않는다.
  - 각각의 JAR 안에 있는 모든 클래스는 classes라는 한 주머니로 합쳐진다.
  - 즉 한 JAR가 다른 JAR에 포함된 클래스 집합을 사용하라고 명시적으로 의존성을 정의하는 기능이 없다.
  
Maven이나 Gradle 같은 빌드 도구는 이런 문제를 해결하는 데 도움을 준다.   

하지만 캡슐화, 클래스 경로 문제가 우리의 소프트웨어에만 발생하는게 아니다.

### 🎈 거대한 JDK
JDK 라이브러리의 많은 내부 API는 공개되지 않아야 한다.   
하지만 안타깝게도 Java의 낮은 캡슐화 지원 때문에 내부 API가 외부에 공개되었다. 

예를 들어 Spring, Netty, Mockito 등 여러 라이브러리에서 sun.misc.Unsafe라는 클래스를 사용했는데,   
이 클래스는 JDK 내부에서만 사용하도록 만든 클래스다. 

결과적으로 호환성을 깨지 않고는 관련 API를 바꾸기가 아주 어려운 상황이 되었다.   
이런 문제들 때문에 JDK 자체도 모듈화할 수 있는 Java 모듈 시스템 설계의 필요성이 제기되었다.

즉 JDK에서 필요한 부분만 골라 사용하고, 클래스 경로를 쉽게 유추할 수 있으며,  
플랫폼을 진화시킬 수 있는 강력한 캡슐화를 제공할 새로운 건축 구조가 필요했다.

## 📚 LESSION 3 : 자바 모듈 : 큰 그림
자바 8는 **모듈** 이라는 새로운 자바 프로그램 구조 단위를 제공하는데,   
모듈은 module이라는 새 키워드에 이름과 바디를 추가해 정의한다.

**모듈 디스크립터(Module descriptor)는 `module-ionfo.java`라는 특별한 파일에 저장된다.

모듈 디스크럽터는 보통 패키지와 같은 폴더에 위치하며 한 개 이상의 패키지를 서술하고 캡슐화할 수 있지만,   
단순한 상황에서는 이들 패키지 중 한 개만 외부로 노출시킨다.

<img width="512" src="https://github.com/Songdoeon/Book_Study/assets/96420547/e238b924-b0e0-4a54-a5b5-b31ca32b7452">

## 📚 LESSION 4 : 자바 모듈 시스템으로 애플리케이션 개발하기
이번 절에서는 간단한 모듈화 애플리케이션을 기초부터 만들며, 자바 9 모듈 시스템 전반을 살펴보겠다.

이 과정에서 작은 모듈화 구조를 세우고, 패키지 및 실행법을 배운다.

### 🎈 애플리케이션 셋업
우리의 애플리케이션은 다음과 같은 작업을 처리해야 한다.
- 애플리케이션은 다음과 같은 여러 작업을 처리해야 한다.
  - 파일이나 URL에서 비용 목록을 읽는다.
  - 비용의 문자열 표현을 파싱한다.
  - 통계를 계산한다.
  - 유용한 요약 정보를 표시한다.
  - 각 태스크의 시작, 마무리 지점을 제공한다.

이제는 애플리케이션의 개념을 모델링할 여러 클래스와 인터페이스를 정의해야 한다.

- 다양한 소스에서 데이터를 읽는다.(Reader, HttpReader, FileReader)
- 다양한 포맷으로 구성된 데이터를 파싱(Parser, JSONParser, ExpenseJSON-Parser)
- 도메인 객체를 구체화(Expense)
- 통계를 계산하고 반환(SummaryCalculator, SummaryStatistics)
- 다양한 기능을 분리 조정(ExpensesApplication)

다음은 교수법에 따라 아주 세부적으로 문제를 나눠보겠다.    
다음처럼 각 기능을 그룹화 할 수 있다.

- expenses.readers
- expenses.readers.http
- expenses.reader.file
- expenses.parsers
- expenses.parsers.json
- expenses.model
- expenses.statistics
- expenses.application

우리는 모듈 시스템의 여러 부분이 두드러질 수 있도록 잘게 분해했다.  
단순한 프로젝트를 이처럼 잘게 분해하여 캡슐화 한다면 장점에 비해 초기 비용이 높아지고, 논란이 생길 수 있다.

하지만 프로젝트가 점점 커지며 많은 내부 구현이 추가되면, 이떄부터 캡슐화와 추론의 장점이 두드러진다.

### 🎈 세부적은 모듈화와 거친 모듈화
시스템 모듈화때에는 모듈 크기를 결정해야 한다.

- 세부적인 모듈화 기법은 대부분 모든 패키지가 자신의 모듈을 갖는다.
  - 이득에 비해 설계 비용이 증가함
- 거친 모듈화 기법 대부분은 한 모듈이 시스템의 모든 패키지를 포함한다.
  - 모듈화의 모든 장점을 잃는다.

가장 좋은 방법은 시스템을 실용적으로 분해하며 진화하는 소프트웨어 프로젝트가 이해하기 쉽고 고치기 쉬운 수준으로    
적절하게 모듈화되어 있는지 주기적으로 확인하는 프로세스를 갖는 것이다.
